import sys
import os
import datetime
import enum
import json
from pathlib import Path

MIN_PRESENTER_MESSAGE_ID = 20

class PresenterMessageId(enum.IntEnum):
    def _generate_next_value_(name, start, count, last_values):
        """generate consecutive automatic numbers starting from zero"""
        return count + MIN_PRESENTER_MESSAGE_ID
    # These are the message ids for the presenter
    # The first message id is MIN_PRESENTER_MESSAGE_ID
    RemoteButtonPressed = enum.auto(),
    BridgeButtonPressed = enum.auto(),
    RemoteHeartBeat = enum.auto(),
    RemoteRequestState = enum.auto(),
    PresenterSetState = enum.auto(),

class PresenterLittleStates(enum.StrEnum):
    # these are the little states that the presenter can tell remotes to be in
    DarkState = 'dark',
    MultipleChoiceState = 'mc',
    EmojiState = 'emoji',

class Definitions:
    uint8_t = ('uint8_t','z.number().int().nonnegative().lte(255)', '8bit unsigned integer'),
    uint8_t_button = ('uint8_t','z.number().int().nonnegative().lt(4)', '8bit unsigned integer between 0 and 4'),
    uint8_t_battery = ('uint8_t','z.number().int().nonnegative().lt(100)', '8bit unsigned integer between 0 and 100'),
    uint16_t = ('uint16_t','z.number().int().nonnegative().lte(65535)', '16bit unsigned integer'),
    uint32_t = ('uint32_t','z.number().int().nonnegative().lte(0xFFFFFFFF)', '32bit unsigned integer'),
    char32_little_state = ('char[32]','LittleStateNamesZ', '32 character string that is a little state name'),

STRUCTS = {
    PresenterMessageId.BridgeButtonPressed.value: {
        'button_id': Definitions.uint8_t_button,
    },
    PresenterMessageId.RemoteButtonPressed.value: {
        'button_id': Definitions.uint8_t_button,
    },
    PresenterMessageId.RemoteHeartBeat.value: {
        'battery_level': Definitions.uint8_t_battery,
    },
    PresenterMessageId.RemoteRequestState.value: {
        'state_hash1': Definitions.uint32_t,
        'state_hash2': Definitions.uint32_t,
        'state_hash3': Definitions.uint32_t,
        'state_hash4': Definitions.uint32_t,
    },
    PresenterMessageId.PresenterSetState.value: {
        'state_name': Definitions.char32_little_state,
    },
}

C_TYPE_TO_PRINT = {
    'uint8_t': 'u',
    'uint16_t': 'u',
    'uint32_t': 'u',
    'char[32]': 's',
}

def generate_common_header() -> list[str]:
    return [
        '/**\n',
        f' AUTOGENERATED ON {datetime.datetime.now()}\n',
        ' DO NOT MODIFY THIS FILE MANUALLY\n',
        ' IT WILL BE OVERWRITTEN ON THE NEXT BUILD\n',
        ' Use the generate.py script in the protocol folder to regenerate this file\n',
        '**/\n\n',
    ]

def generate_typescript(file_path: Path):
    with open(file_path, 'w') as f:
        f.writelines(generate_common_header())
        f.write('import {z} from "zod";\n\n')
        # Now we need to generate an enum for each of the PresenterMessageIds
        f.write("export enum PresenterMessageId {\n")
        for message_id in PresenterMessageId:
            f.write(f"    {message_id.name} = {message_id.value},\n")
        f.write("};\n")
        f.write("const PresenterMessageIdZ = z.nativeEnum(PresenterMessageId);\n\n")
        # also generate the little state enum
        f.write("export enum LittleStateNames {\n")
        for little_state in PresenterLittleStates:
            f.write(f"    {little_state.name} = '{little_state.value}',\n")
        f.write("};\n")
        f.write("const LittleStateNamesZ = z.nativeEnum(LittleStateNames);\n\n")

        f.write("const PresenterMessageBaseZ = z.object({id: PresenterMessageIdZ});\n")

        for message_id in PresenterMessageId:
            f.write(f'export const Protocol{message_id.name}Z = PresenterMessageBaseZ.extend({{\n')
            f.write(f"    id: z.literal(PresenterMessageId.{message_id.name}),\n")
            fields = STRUCTS.get(message_id.value, {})
            for field in fields:
                _, zod_type, comment = fields[field][0]
                f.write(f"    {field}: {zod_type}, // {comment} \n")
            f.write("});\n")
            f.write(f"export type Protocol{message_id.name} = z.infer<typeof Protocol{message_id.name}Z>;\n")
            f.write('\n')

        # now generate a matching function
        f.write("export function parsePresenterMessage(data: object) {\n")
        for message_id in PresenterMessageId:
            f.write("    try {\n")
            f.write(f"        return Protocol{message_id.name}Z.parse(data);\n")
            f.write("    } catch(e) {}\n\n")
        f.write("    return null;\n")
        f.write("}\n")

        f.write("export type PresenterMessage = ")
        f.write(" | ".join([f"Protocol{message_id.name}" for message_id in PresenterMessageId]))
        f.write(";")

def generate_c_header(file_path: Path):
    with open(file_path, 'w') as f:
        f.writelines(generate_common_header())
        f.write("#pragma once\n\n")
        f.write("#include <stdint.h>\n")
        f.write("#include <stdlib.h>\n")
        f.write("\n")
        f.write(f"#define MIN_PRESENTER_MESSAGE_ID {MIN_PRESENTER_MESSAGE_ID}")

        f.write("\nenum PresenterMessageId {\n")
        for message_id in PresenterMessageId:
            f.write(f"    {message_id.name} = {message_id.value},\n")
        f.write("};\n")

        for message_id in PresenterMessageId:
            struct_name = f"Presenter{message_id.name}_t"
            f.write(f"typedef struct {{\n")
            f.write(f"    uint8_t id; // PresenterMessageIds.{message_id.name}\n")
            fields = STRUCTS.get(message_id.value, {})
            for field in fields:
                c_type, _, comment = fields[field][0]
                field_end = ""
                if c_type.endswith("]"):
                    c_type, field_end = c_type.split("[")
                    field_end = f"[{field_end}"
                f.write(f"    {c_type} {field}{field_end}; // {comment}\n")
            f.write(f"}} {struct_name};\n\n")
            # now generate macro to generate this field
            # we need to generate a list of a,b,c based on the number of items in fields
            macro_args_list = ",".join([f"_{i}" for i in range(len(fields)+1)])
            f.write(f"#define PRESENTER_{message_id.name.upper()}({macro_args_list}) \\\n")
            f.write(f"    {struct_name} _0 = {{ \\\n")
            f.write(f"        .id = {message_id.name}, \\\n")
            for i, field in enumerate(fields):
                f.write(f"        .{field} = _{i+1}, \\\n")
            f.write("    }\n")
            #sizeof(struct Presenter{message_id.name})\n")
            f.write("\n")
        f.write("\n")
        # now we need to write a function that turns the message into a json object
        f.write("char* presenter_message_to_json(const uint8_t* message, const uint32_t message_size) {\n")
        for message_id in PresenterMessageId:
            struct_name = f"Presenter{message_id.name}_t"
            f.write(f"    if (message[0] == {message_id.name}) {{\n")
            f.write(f"        {struct_name}* msg = ({struct_name}*)message;\n")
            format_str = f"\"{{'id':'{message_id.name}'"
            fields = STRUCTS.get(message_id.value, {})
            for field in fields:
                marker = C_TYPE_TO_PRINT.get(fields[field][0][0])
                format_str += f",'{field}':%{marker}" if marker != 's' else f",'{field}':'%{marker}'"
            format_str += '}"'
            va_args = ", ".join([f"msg->{field}" for field in fields])
            f.write(f"        int size_needed = snprintf(NULL, 0, {format_str}, {va_args});\n")
            f.write(f"        char* json = (char*)malloc(size_needed+1);\n")
            f.write(f"        if (json != NULL) return NULL;\n")
            f.write(f"        bzero(json, size_needed+1);\n")
            f.write(f"        snprintf(json, size_needed, {format_str}, {va_args});\n")
            # f.write("        }\"")
            f.write(f"        return json;\n")
            f.write(f"    }}\n")
        f.write("    return NULL;\n")
        f.write("}\n")
        



def main():
    # first we need to find the path of the folder this file is in
    # then we need to find the path of the folder above this folder
    root_dir = Path(__file__).resolve().parent.parent
    # get the path to presenter/src/common/Protocol.ts relative to the root dir
    protocol_path = root_dir / "presenter" / "src" / "common" / "Protocol.ts"
    # now get the path to the firmware/lib/OpenClicker/include/protocol/presenter_protocol.h relative to the root dir
    firmware_path = root_dir / "firmware" / "lib" / "OpenClicker" / "include" / "protocol" / "presenter_protocol.h"
    # now we need to generate the typescript
    protocol_path.unlink(missing_ok=True)
    generate_typescript(protocol_path)
    firmware_path.unlink(missing_ok=True)
    generate_c_header(firmware_path)
    return 0


if __name__ == "__main__":
    sys.exit(main())